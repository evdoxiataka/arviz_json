<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">

<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>NPZ loader test</title>

    <head>
        <script src="../js/zip/zip.js"></script>
        <script src="../js/zip/zip-ext.js"></script>
        <script src="../js/zip/inflate.js"></script>
        <script src="../js/npy.js"></script>
        <script src="../js/npz.js"></script>
        <script src="../js/arviz.js"></script>
        <link rel="stylesheet" type="text/css" href="demo_model_style.css" />
    </head>

<body>
    <svg></svg>
    <script src="https://d3js.org/d3.v4.min.js"></script>

    <script>
        function drawChart(arviz_data) {

            var observed = arviz_data.observed_data.vars;
            var posterior = arviz_data.posterior.vars;
            var prior = arviz_data.prior.vars;

            function getData(array_data) {
                return array_data.array.data;
            }

            function getSample(property, vars)
            {
                var property_block = arviz_data[property].vars;
                var v0 = vars[0];
                var random_index = Math.floor(Math.random() * getData(property_block[v0]).length);
                var samples = {};
                for (i = 0; i < vars.length; i++) {
                    var v = vars[i];
                    samples[v] = getData(property_block[v])[random_index];
                }
                return samples;
            }

            // return a single random sample from the trace
            function getPosteriorSample(vars) {
                return getSample("posterior", vars)
            }

            // return a single random sample from the trace, and from the prior
            // and linearly interpolate between them according to the given factor
            function getLinearPriorPosteriorSample(vars, w) {
                var posterior_samples = getPosteriorSample(vars);
                var prior_samples = getSample("prior", vars);
                var weighted_samples = {}
                for(v in posterior_samples)
                {
                    weighted_samples[v] = (1-w) * posterior_samples[v] + (w) * prior_samples[v];
                }                                
                return weighted_samples;
            }

            // return average trace values
            function getPosteriorExpectation(vars) {
                expectations = {};
                var trace_length = getData(posterior[vars[0]]).length;
                for (i = 0; i < vars.length; i++) {
                    var v = vars[i];
                    expectations[v] = getData(posterior[v]).reduce((a,b)=>a+b)/trace_length;
                }
                return expectations;
            }

            // Remap values
            function remap(array, fn) {
                array.array.data = array.array.data.map(fn);
            }

            // remap transformed variables            
            remap(posterior.switchpoint, x => x + 1960);
            remap(posterior.poverty_at_switchpoint, x => x + 50);
            remap(prior.switchpoint, x => x + 1960);
            remap(prior.poverty_at_switchpoint, x => x + 50);
            
            remap(observed.year, x => x + 1960);
            remap(observed.y, x => x + 50);


            // select
            var raw_data = {
                "date": getData(observed.year),
                "value": getData(observed.y),
            }

            // transpose 
            var data = [];
            for (var i = 0; i < raw_data.date.length; i++) {
                data.push({
                    "date": raw_data.date[i],
                    "value": raw_data.value[i],
                })
            }

            var width, height;

            function createCanvas() {
                // create canvas
                var svgWidth = 1000,
                    svgHeight = 400;
                var margin = {
                    top: 60,
                    right: 100,
                    bottom: 100,
                    left: 100
                };
                width = svgWidth - margin.left - margin.right;
                height = svgHeight - margin.top - margin.bottom;
                var svg = d3.select('svg')
                    .attr("width", svgWidth)
                    .attr("height", svgHeight)
                    .attr("id", "canvas");


                // main group for all elements
                var g = svg.append("g")
                    .attr("transform",
                        "translate(" + margin.left + "," + margin.top + ")"
                    );
                return g;
            }

            g = createCanvas();


            // construct axis objects
            var x = d3.scaleLinear().rangeRound([0, width]);
            var y = d3.scaleLinear().rangeRound([height, 0]);

            // construct the line 
            var line = d3.line()
                .x(function (d) {
                    return x(d.date)
                })
                .y(function (d) {
                    return y(d.value)
                })
            x.domain(d3.extent(data, function (d) {
                return d.date;
            }));
            y.domain([0, 100]);

            // add axis guides
            g.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x))
                .attr("class", "tickLabel")

                .append("text")
                .attr("class", "axisLabel")
                .attr("text-anchor", "middle")
                .attr("dy", "40px")
                .text("Year");


            g.append("g")
                .call(d3.axisLeft(y))
                .attr("class", "tickLabel")
                .append("text")
                .attr("class", "axisLabel")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", "-40px")
                .attr("text-anchor", "end")
                .text("Poverty rate");

            // add scatter plot
            g.append("g")
                .attr("class", "scatterplot")
                .selectAll("circle")
                .data(data)
                .enter()
                .append("circle")
                .attr("cx", d => x(d.date))
                .attr("cy", d => y(d.value))
                .attr("r", 2);


            var useExpectation = true;
            var priorWeight = 0.0;
            var priorIntegrator = 0.0;

            function enable_anim() {
                useExpectation = false;                
            }

            function disable_anim() {
                useExpectation = true;            
            }

            function dwell()
            {
                priorIntegrator = 0.01;
            }

            function relax()
            {
                priorIntegrator = -0.01;
            }

            // add interaction
            d3.select("svg")
            .on("mousedown", dwell)
            .on("mouseup", relax)
            .on("mouseenter", enable_anim)
            .on("mouseleave", disable_anim);



            // draw a piecewise linear path, with a given
            // std. dev ribbon plot
            function setLinePath(sampleData, sigma) {
                d3.select("#mean").remove();
                d3.select("#ribbon").remove();


                g.append("path")
                    .datum(sampleData)
                    .attr("id", "mean")
                    .attr("d", line);

                g.append("path")
                    .datum(sampleData)
                    .attr("id", "ribbon")
                    .attr("stroke-width", 0.5 * y(sigma + 50))
                    .attr("d", line);
            }

            // update prior weight, by saturated integration
            function updateState()
            {
                priorWeight = Math.tanh(priorWeight+priorIntegrator);                
            }

            function drawSample() {
                // select a random sample, and draw the corresponding model

                var pSample;
                if(useExpectation)
                {
                    // static mean
                    pSample = getPosteriorExpectation(["sigma", "left_slope", "right_slope",
                        "switchpoint", "poverty_at_switchpoint"]);            
                }
                else if(priorWeight>1e-2)
                {
                    // weighted sample between random prior and posterior
                    pSample = getLinearPriorPosteriorSample(["sigma", "left_slope", "right_slope",
                        "switchpoint", "poverty_at_switchpoint"
                    ], priorWeight);
                }
                else
                {
                    // plain posterior sample
                    pSample = getPosteriorSample(["sigma", "left_slope", "right_slope",
                        "switchpoint", "poverty_at_switchpoint"
                    ]);
                }

                function map_line(at, slope, from, offset) {
                    return offset + (at - from) * slope;
                }

                // construct the linear segments
                var sample_data = [{
                        date: 1820,
                        value: map_line(1820, pSample.left_slope, pSample.switchpoint, pSample.poverty_at_switchpoint)
                    },
                    {
                        date: pSample.switchpoint,
                        value: map_line(pSample.switchpoint, pSample.left_slope, pSample.switchpoint, pSample.poverty_at_switchpoint)
                    },
                    {
                        date: 2010,
                        value: map_line(2010, pSample.right_slope, pSample.switchpoint, pSample.poverty_at_switchpoint)
                    },
                ];

                setLinePath(sample_data, pSample.sigma);

                // update state variables
                updateState();
            }

            // begin animating the draws
            window.setInterval(function () {
                drawSample();
            }, 50);
        }

        load_npz("switchpoint.npz", function (npz_data) {
            drawChart(reassemble_arviz(npz_data));
        });
    </script>


</body>

</body>

</html>